<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>BinaryBuilderBase.jl Documentation · BinaryBuilderBase.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">BinaryBuilderBase.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>BinaryBuilderBase.jl Documentation</a><ul class="internal"><li><a class="tocitem" href="#Index-1"><span>Index</span></a></li><li><a class="tocitem" href="#Types-1"><span>Types</span></a></li><li><a class="tocitem" href="#Functions-1"><span>Functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>BinaryBuilderBase.jl Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>BinaryBuilderBase.jl Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="BinaryBuilderBase.jl-Documentation-1"><a class="docs-heading-anchor" href="#BinaryBuilderBase.jl-Documentation-1">BinaryBuilderBase.jl Documentation</a><a class="docs-heading-anchor-permalink" href="#BinaryBuilderBase.jl-Documentation-1" title="Permalink"></a></h1><p>This is the reference documentation of <a href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl"><code>BinaryBuilderBase.jl</code></a>.</p><h2 id="Index-1"><a class="docs-heading-anchor" href="#Index-1">Index</a><a class="docs-heading-anchor-permalink" href="#Index-1" title="Permalink"></a></h2><ul><li><a href="#BinaryBuilderBase.AbstractDependency"><code>BinaryBuilderBase.AbstractDependency</code></a></li><li><a href="#BinaryBuilderBase.AbstractSource"><code>BinaryBuilderBase.AbstractSource</code></a></li><li><a href="#BinaryBuilderBase.AnyPlatform"><code>BinaryBuilderBase.AnyPlatform</code></a></li><li><a href="#BinaryBuilderBase.ArchiveSource"><code>BinaryBuilderBase.ArchiveSource</code></a></li><li><a href="#BinaryBuilderBase.BuildDependency"><code>BinaryBuilderBase.BuildDependency</code></a></li><li><a href="#BinaryBuilderBase.Dependency"><code>BinaryBuilderBase.Dependency</code></a></li><li><a href="#BinaryBuilderBase.DirectorySource"><code>BinaryBuilderBase.DirectorySource</code></a></li><li><a href="#BinaryBuilderBase.DockerRunner"><code>BinaryBuilderBase.DockerRunner</code></a></li><li><a href="#BinaryBuilderBase.ExecutableProduct"><code>BinaryBuilderBase.ExecutableProduct</code></a></li><li><a href="#BinaryBuilderBase.FileProduct"><code>BinaryBuilderBase.FileProduct</code></a></li><li><a href="#BinaryBuilderBase.FileSource"><code>BinaryBuilderBase.FileSource</code></a></li><li><a href="#BinaryBuilderBase.FrameworkProduct"><code>BinaryBuilderBase.FrameworkProduct</code></a></li><li><a href="#BinaryBuilderBase.GitSource"><code>BinaryBuilderBase.GitSource</code></a></li><li><a href="#BinaryBuilderBase.HostBuildDependency"><code>BinaryBuilderBase.HostBuildDependency</code></a></li><li><a href="#BinaryBuilderBase.LibraryProduct"><code>BinaryBuilderBase.LibraryProduct</code></a></li><li><a href="#BinaryBuilderBase.Product"><code>BinaryBuilderBase.Product</code></a></li><li><a href="#BinaryBuilderBase.UserNSRunner"><code>BinaryBuilderBase.UserNSRunner</code></a></li><li><a href="#BinaryBuilderBase.abi_agnostic-Tuple{Platform}"><code>BinaryBuilderBase.abi_agnostic</code></a></li><li><a href="#BinaryBuilderBase.accept_apple_sdk-Tuple{IO, IO}"><code>BinaryBuilderBase.accept_apple_sdk</code></a></li><li><a href="#BinaryBuilderBase.artifact_name-Tuple{CompilerShard}"><code>BinaryBuilderBase.artifact_name</code></a></li><li><a href="#BinaryBuilderBase.bindir-Tuple{Prefix}"><code>BinaryBuilderBase.bindir</code></a></li><li><a href="#BinaryBuilderBase.choose_shards-Tuple{Base.BinaryPlatforms.AbstractPlatform}"><code>BinaryBuilderBase.choose_shards</code></a></li><li><a href="#BinaryBuilderBase.chown_cleanup-Tuple{DockerRunner}"><code>BinaryBuilderBase.chown_cleanup</code></a></li><li><a href="#BinaryBuilderBase.collect_jll_uuids-Tuple{Pkg.Types.Manifest, Set{Base.UUID}}"><code>BinaryBuilderBase.collect_jll_uuids</code></a></li><li><a href="#BinaryBuilderBase.compress_dir-Tuple{AbstractString}"><code>BinaryBuilderBase.compress_dir</code></a></li><li><a href="#BinaryBuilderBase.download_all_artifacts-Tuple{}"><code>BinaryBuilderBase.download_all_artifacts</code></a></li><li><a href="#BinaryBuilderBase.download_source"><code>BinaryBuilderBase.download_source</code></a></li><li><a href="#BinaryBuilderBase.enable_apple_file-Tuple{}"><code>BinaryBuilderBase.enable_apple_file</code></a></li><li><a href="#BinaryBuilderBase.expand_cxxstring_abis-Tuple{Base.BinaryPlatforms.AbstractPlatform}"><code>BinaryBuilderBase.expand_cxxstring_abis</code></a></li><li><a href="#BinaryBuilderBase.expand_gfortran_versions-Tuple{Base.BinaryPlatforms.AbstractPlatform}"><code>BinaryBuilderBase.expand_gfortran_versions</code></a></li><li><a href="#BinaryBuilderBase.expand_microarchitectures"><code>BinaryBuilderBase.expand_microarchitectures</code></a></li><li><a href="#BinaryBuilderBase.expand_microarchitectures"><code>BinaryBuilderBase.expand_microarchitectures</code></a></li><li><a href="#BinaryBuilderBase.filter_platforms-Tuple{AbstractVector{&lt;:AbstractDependency}, Base.BinaryPlatforms.AbstractPlatform}"><code>BinaryBuilderBase.filter_platforms</code></a></li><li><a href="#BinaryBuilderBase.gcc_version"><code>BinaryBuilderBase.gcc_version</code></a></li><li><a href="#BinaryBuilderBase.generate_compiler_wrappers!-Tuple{Base.BinaryPlatforms.AbstractPlatform}"><code>BinaryBuilderBase.generate_compiler_wrappers!</code></a></li><li><a href="#BinaryBuilderBase.generate_per_uid_squashfs"><code>BinaryBuilderBase.generate_per_uid_squashfs</code></a></li><li><a href="#BinaryBuilderBase.get_addable_spec-Tuple{AbstractString, VersionNumber}"><code>BinaryBuilderBase.get_addable_spec</code></a></li><li><a href="#BinaryBuilderBase.get_commit_sha-Tuple{String, Base.SHA1}"><code>BinaryBuilderBase.get_commit_sha</code></a></li><li><a href="#BinaryBuilderBase.get_concrete_platform-Tuple{Base.BinaryPlatforms.AbstractPlatform}"><code>BinaryBuilderBase.get_concrete_platform</code></a></li><li><a href="#BinaryBuilderBase.get_concrete_platform-Tuple{Platform, Vector{CompilerShard}}"><code>BinaryBuilderBase.get_concrete_platform</code></a></li><li><a href="#BinaryBuilderBase.get_tree_hash-Tuple{LibGit2.GitTree}"><code>BinaryBuilderBase.get_tree_hash</code></a></li><li><a href="#BinaryBuilderBase.getgid-Tuple{}"><code>BinaryBuilderBase.getgid</code></a></li><li><a href="#BinaryBuilderBase.getuid-Tuple{}"><code>BinaryBuilderBase.getuid</code></a></li><li><a href="#BinaryBuilderBase.import_docker_image-Tuple{CompilerShard, String}"><code>BinaryBuilderBase.import_docker_image</code></a></li><li><a href="#BinaryBuilderBase.includedir-Tuple{Prefix}"><code>BinaryBuilderBase.includedir</code></a></li><li><a href="#BinaryBuilderBase.installed_shards-Tuple{}"><code>BinaryBuilderBase.installed_shards</code></a></li><li><a href="#BinaryBuilderBase.is_build_dependency"><code>BinaryBuilderBase.is_build_dependency</code></a></li><li><a href="#BinaryBuilderBase.is_ecryptfs-Tuple{AbstractString}"><code>BinaryBuilderBase.is_ecryptfs</code></a></li><li><a href="#BinaryBuilderBase.is_host_dependency"><code>BinaryBuilderBase.is_host_dependency</code></a></li><li><a href="#BinaryBuilderBase.is_mounted-Tuple{CompilerShard, AbstractString}"><code>BinaryBuilderBase.is_mounted</code></a></li><li><a href="#BinaryBuilderBase.is_runtime_dependency"><code>BinaryBuilderBase.is_runtime_dependency</code></a></li><li><a href="#BinaryBuilderBase.is_target_dependency-Tuple{AbstractDependency}"><code>BinaryBuilderBase.is_target_dependency</code></a></li><li><a href="#BinaryBuilderBase.libdirs"><code>BinaryBuilderBase.libdirs</code></a></li><li><a href="#BinaryBuilderBase.locate-Tuple{FileProduct, Prefix}"><code>BinaryBuilderBase.locate</code></a></li><li><a href="#BinaryBuilderBase.locate-Tuple{ExecutableProduct, Prefix}"><code>BinaryBuilderBase.locate</code></a></li><li><a href="#BinaryBuilderBase.locate-Tuple{LibraryProduct, Prefix}"><code>BinaryBuilderBase.locate</code></a></li><li><a href="#BinaryBuilderBase.logdir-Tuple{Prefix}"><code>BinaryBuilderBase.logdir</code></a></li><li><a href="#BinaryBuilderBase.macos_sdk_already_installed-Tuple{}"><code>BinaryBuilderBase.macos_sdk_already_installed</code></a></li><li><a href="#BinaryBuilderBase.map_target-Tuple{CompilerShard}"><code>BinaryBuilderBase.map_target</code></a></li><li><a href="#BinaryBuilderBase.mount-Tuple{CompilerShard, AbstractString}"><code>BinaryBuilderBase.mount</code></a></li><li><a href="#BinaryBuilderBase.package-Tuple{Prefix, AbstractString, VersionNumber}"><code>BinaryBuilderBase.package</code></a></li><li><a href="#BinaryBuilderBase.platform_envs-Tuple{Base.BinaryPlatforms.AbstractPlatform, AbstractString}"><code>BinaryBuilderBase.platform_envs</code></a></li><li><a href="#BinaryBuilderBase.platform_exeext-Tuple{Base.BinaryPlatforms.AbstractPlatform}"><code>BinaryBuilderBase.platform_exeext</code></a></li><li><a href="#BinaryBuilderBase.preferred_cxxstring_abi-Tuple{Base.BinaryPlatforms.AbstractPlatform, CompilerShard}"><code>BinaryBuilderBase.preferred_cxxstring_abi</code></a></li><li><a href="#BinaryBuilderBase.preferred_libgfortran_version-Tuple{Base.BinaryPlatforms.AbstractPlatform, CompilerShard}"><code>BinaryBuilderBase.preferred_libgfortran_version</code></a></li><li><a href="#BinaryBuilderBase.runshell"><code>BinaryBuilderBase.runshell</code></a></li><li><a href="#BinaryBuilderBase.satisfied-Tuple{Product, Prefix}"><code>BinaryBuilderBase.satisfied</code></a></li><li><a href="#BinaryBuilderBase.setup_dependencies-Tuple{Prefix, Vector{Pkg.Types.PackageSpec}, Base.BinaryPlatforms.AbstractPlatform}"><code>BinaryBuilderBase.setup_dependencies</code></a></li><li><a href="#BinaryBuilderBase.setup_workspace"><code>BinaryBuilderBase.setup_workspace</code></a></li><li><a href="#BinaryBuilderBase.shard_mappings-Tuple{Vector{CompilerShard}}"><code>BinaryBuilderBase.shard_mappings</code></a></li><li><a href="#BinaryBuilderBase.shard_path-Tuple{CompilerShard}"><code>BinaryBuilderBase.shard_path</code></a></li><li><a href="#BinaryBuilderBase.supported_platforms-Tuple{}"><code>BinaryBuilderBase.supported_platforms</code></a></li><li><a href="#BinaryBuilderBase.temp_prefix-Tuple{Function}"><code>BinaryBuilderBase.temp_prefix</code></a></li><li><a href="#BinaryBuilderBase.uname-Tuple{}"><code>BinaryBuilderBase.uname</code></a></li><li><a href="#BinaryBuilderBase.unmount-Tuple{CompilerShard, String}"><code>BinaryBuilderBase.unmount</code></a></li><li><a href="#BinaryBuilderBase.variable_name-Tuple{Product}"><code>BinaryBuilderBase.variable_name</code></a></li><li><a href="#BinaryBuilderBase.versioninfo-Tuple{}"><code>BinaryBuilderBase.versioninfo</code></a></li></ul><h2 id="Types-1"><a class="docs-heading-anchor" href="#Types-1">Types</a><a class="docs-heading-anchor-permalink" href="#Types-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.AbstractDependency" href="#BinaryBuilderBase.AbstractDependency"><code>BinaryBuilderBase.AbstractDependency</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An <code>AbstractDependency</code> is a binary dependency of the JLL package.  Dependencies are installed to <code>${prefix}</code> in the build environment.</p><p>Concrete subtypes of <code>AbstractDependency</code> are</p><ul><li><a href="#BinaryBuilderBase.Dependency"><code>Dependency</code></a>: a JLL package that is necessary for to build the package and to load the generated JLL package.</li><li><a href="#BinaryBuilderBase.BuildDependency"><code>BuildDependency</code></a>: a JLL package that is necessary only to build the package.  This will not be a dependency of the generated JLL package.</li><li><a href="#BinaryBuilderBase.HostBuildDependency"><code>HostBuildDependency</code></a>: similar to <code>BuildDependency</code>, but it will install the artifact for the host platform, instead of that for the target platform.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Dependencies.jl#L13-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.AbstractSource" href="#BinaryBuilderBase.AbstractSource"><code>BinaryBuilderBase.AbstractSource</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An <code>AbstractSource</code> is something used as source to build the package.  Sources are installed to <code>${WORKSPACE}/srcdir</code> in the build environment.</p><p>Concrete subtypes of <code>AbstractSource</code> are:</p><ul><li><a href="#BinaryBuilderBase.ArchiveSource"><code>ArchiveSource</code></a>: a remote archive to download from the Internet;</li><li><a href="#BinaryBuilderBase.FileSource"><code>FileSource</code></a>: a remote file to download from the Internet;</li><li><a href="#BinaryBuilderBase.GitSource"><code>GitSource</code></a>: a remote Git repository to clone;</li><li><a href="#BinaryBuilderBase.DirectorySource"><code>DirectorySource</code></a>: a local directory to mount.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Sources.jl#L5-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.AnyPlatform" href="#BinaryBuilderBase.AnyPlatform"><code>BinaryBuilderBase.AnyPlatform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AnyPlatform()</code></pre><p>A special platform to be used to build platform-independent tarballs, like those containing only header files.  <a href="#BinaryBuilderBase.FileProduct"><code>FileProduct</code></a> is the only product type allowed with this platform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Platforms.jl#L6-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.ArchiveSource" href="#BinaryBuilderBase.ArchiveSource"><code>BinaryBuilderBase.ArchiveSource</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ArchiveSource(url::String, hash::String; unpack_target::String = &quot;&quot;)</code></pre><p>Specify a remote archive in one of the supported archive formats (e.g., TAR or ZIP balls) to be downloaded from the Internet from <code>url</code>.  <code>hash</code> is the 64-character SHA256 checksum of the file.</p><p>In the builder environment, the archive will be automatically unpacked to <code>${WORKSPACE}/srcdir</code>, or in its subdirectory pointed to by the optional keyword <code>unpack_target</code>, if provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Sources.jl#L18-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.BuildDependency" href="#BinaryBuilderBase.BuildDependency"><code>BinaryBuilderBase.BuildDependency</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BuildDependency(dep::Union{PackageSpec,String}; platforms)</code></pre><p>Define a binary dependency that is necessary only to build the package.  The <code>dep</code> argument can be either a string with the name of the JLL package or a <code>Pkg.PackageSpec</code>.</p><p>The optional keyword argument <code>platforms</code> is a vector of <code>AbstractPlatform</code>s which indicates for which platforms the dependency should be used.  By default <code>platforms=[AnyPlatform()]</code>, to mean that the dependency is compatible with all platforms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Dependencies.jl#L110-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.Dependency" href="#BinaryBuilderBase.Dependency"><code>BinaryBuilderBase.Dependency</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Dependency(dep::Union{PackageSpec,String}, build_version; compat, platforms)</code></pre><p>Define a binary dependency that is necessary to build the package and load the generated JLL package.  The argument can be either a string with the name of the JLL package or a <code>Pkg.PackageSpec</code>.</p><p>The optional keyword argument <code>build_version</code> can be used to specify the version of the dependency to be installed when building it.</p><p>The optional keyword argument <code>compat</code> can be used to specify a string for use in the <code>Project.toml</code> of the generated Julia package.  If <code>compat</code> is non-empty and <code>build_version</code> is not passed, the latter defaults to the minimum version compatible with the <code>compat</code> specifier.</p><p>The optional keyword argument <code>platforms</code> is a vector of <code>AbstractPlatform</code>s which indicates for which platforms the dependency should be used.  By default <code>platforms=[AnyPlatform()]</code>, to mean that the dependency is compatible with all platforms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Dependencies.jl#L57-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.DirectorySource" href="#BinaryBuilderBase.DirectorySource"><code>BinaryBuilderBase.DirectorySource</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DirectorySource(path::String; target::String = basename(path), follow_symlinks=false)</code></pre><p>Specify a local directory to mount from <code>path</code>.</p><p>The content of the directory will be mounted in <code>${WORKSPACE}/srcdir</code>, or in its subdirectory pointed to by the optional keyword <code>target</code>, if provided. Symbolic links are replaced by a copy of the target when <code>follow_symlinks</code> is <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Sources.jl#L78-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.DockerRunner" href="#BinaryBuilderBase.DockerRunner"><code>BinaryBuilderBase.DockerRunner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DockerRunner</code></pre><p>Use <code>docker</code> as an execution engine; a reasonable backup for platforms that do not have user namespaces (e.g. MacOS, Windows).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/DockerRunner.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.ExecutableProduct" href="#BinaryBuilderBase.ExecutableProduct"><code>BinaryBuilderBase.ExecutableProduct</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An <code>ExecutableProduct</code> is a <a href="#BinaryBuilderBase.Product"><code>Product</code></a> that represents an executable file.</p><p>On all platforms, an ExecutableProduct checks for existence of the file.  On non-Windows platforms, it will check for the executable bit being set.  On Windows platforms, it will check that the file ends with &quot;.exe&quot;, (adding it on automatically, if it is not already present).</p><hr/><pre><code class="language-none">ExecutableProduct(binname, varname::Symbol, dir_path=&quot;bin&quot;)</code></pre><p>Declares an <code>ExecutableProduct</code> that points to an executable located within the prefix.  <code>binname</code> specifies the basename of the executable, <code>varname</code> is the name of the variable in the JLL package that can be used to call into the library.  By default, the library is searched in the <code>bindir</code>, but you can specify a different directory within the prefix with the <code>dir_path</code> argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Products.jl#L332-L349">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.FileProduct" href="#BinaryBuilderBase.FileProduct"><code>BinaryBuilderBase.FileProduct</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FileProduct(path::AbstractString, varname::Symbol, dir_path = nothing)</code></pre><p>Declares a <a href="#BinaryBuilderBase.FileProduct"><code>FileProduct</code></a> that points to a file located relative to the root of a <code>Prefix</code>, must simply exist to be satisfied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Products.jl#L443-L448">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.FileSource" href="#BinaryBuilderBase.FileSource"><code>BinaryBuilderBase.FileSource</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FileSource(url::String, hash::String; filename::String = basename(url))</code></pre><p>Specify a remote file to be downloaded from the Internet from <code>url</code>.  <code>hash</code> is the 64-character SHA256 checksum of the file.</p><p>In the builder environment, the file will be saved under <code>${WORKSPACE}/srcdir</code> with the same name as the basename of the originating URL, unless the the keyword argument <code>filename</code> is specified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Sources.jl#L43-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.FrameworkProduct" href="#BinaryBuilderBase.FrameworkProduct"><code>BinaryBuilderBase.FrameworkProduct</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>FrameworkProduct</code> is a  <a href="#BinaryBuilderBase.Product"><code>Product</code></a> that encapsulates a macOS Framework. It behaves mostly as a <a href="#BinaryBuilderBase.LibraryProduct"><code>LibraryProduct</code></a> for now, but is a distinct type. This implies that for cross-platform builds where a library is provided as a Framework on macOS and as a normal library on other platforms, two calls to BinaryBuilder&#39;s <code>build_tarballs</code> are needed: one with the <code>LibraryProduct</code> and all non-macOS platforms, and one with the <code>FrameworkProduct</code> and the <code>MacOS</code> platforms.</p><hr/><pre><code class="language-none">FrameworkProduct(fwnames, varname::Symbol)</code></pre><p>Declares a macOS <code>FrameworkProduct</code> that points to a framework located within the prefix, with a name containing <code>fwname</code> appended with <code>.framework</code>.  As an example, given that <code>fwname</code> is equal to <code>QtCore</code>, this would be satisfied by the following path:</p><pre><code class="language-none">lib/QtCore.framework</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Products.jl#L258-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.GitSource" href="#BinaryBuilderBase.GitSource"><code>BinaryBuilderBase.GitSource</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GitSource(url::String, hash::String; unpack_target::String = &quot;&quot;)</code></pre><p>Specify a remote Git repository to clone form <code>url</code>.  <code>hash</code> is the 40-character SHA1 revision to checkout after cloning.</p><p>The repository will be cloned in <code>${WORKSPACE}/srcdir</code>, or in its subdirectory pointed to by the optional keyword <code>unpack_target</code>, if provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Sources.jl#L61-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.HostBuildDependency" href="#BinaryBuilderBase.HostBuildDependency"><code>BinaryBuilderBase.HostBuildDependency</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HostBuildDependency(dep::Union{PackageSpec,String}; platforms)</code></pre><p>Define a binary dependency that is necessary only to build the package. Different from the <a href="#BinaryBuilderBase.BuildDependency"><code>BuildDependency</code></a>, the artifact for the host platform will be installed, instead of that for the target platform.</p><p>The <code>dep</code> argument can be either a string with the name of the JLL package or a <code>Pkg.PackageSpec</code>.</p><p>The optional keyword argument <code>platforms</code> is a vector of <code>AbstractPlatform</code>s which indicates for which platforms the dependency should be used.  By default <code>platforms=[AnyPlatform()]</code>, to mean that the dependency is compatible with all platforms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Dependencies.jl#L134-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.LibraryProduct" href="#BinaryBuilderBase.LibraryProduct"><code>BinaryBuilderBase.LibraryProduct</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>LibraryProduct</code> is a special kind of <a href="#BinaryBuilderBase.Product"><code>Product</code></a> that not only needs to exist, but needs to be <code>dlopen()</code>&#39;able.  You must know which directory the library will be installed to, and its name, e.g. to build a <code>LibraryProduct</code> that refers to <code>&quot;/lib/libnettle.so&quot;</code>, the &quot;directory&quot; would be &quot;/lib&quot;, and the &quot;libname&quot; would be &quot;libnettle&quot;.  Note that a <code>LibraryProduct</code> can support multiple libnames, as some software projects change the libname based on the build configuration.</p><hr/><pre><code class="language-none">LibraryProduct(libname, varname::Symbol; dir_paths=String[],
                                         dont_dlopen=false,
                                         dlopen_flags=Symbol[])</code></pre><p>Declares a <code>LibraryProduct</code> that points to a library located within the prefix. <code>libname</code> specifies the basename of the library, <code>varname</code> is the name of the variable in the JLL package that can be used to call into the library.  By default, the library is searched in the <code>libdir</code>, but you can add other directories within the prefix to the <code>dir_paths</code> keyword argument.  You can specify the flags to pass to <code>dlopen</code> as a vector of <code>Symbols</code> with the <code>dlopen_flags</code> keyword argument.  If the library should not be dlopen&#39;ed automatically by the JLL package, set <code>dont_dlopen=true</code>.</p><p>For example, if the <code>libname</code> is <code>libnettle</code>, this would be satisfied by the following paths:</p><ul><li><code>lib/libnettle.so</code> or <code>lib/libnettle.so.6</code> on Linux and FreeBSD;</li><li><code>lib/libnettle.6.dylib</code> on macOS;</li><li><code>lib/libnettle-6.dll</code> on Windows.</li></ul><p>Libraries matching the search pattern are rejected if they are not <code>dlopen()</code>&#39;able.</p><p>If you are unsure what value to use for <code>libname</code>, you can use <code>Base.BinaryPlatforms.parse_dl_name_version</code>:</p><pre><code class="language-none">julia&gt; using Base.BinaryPlatforms

julia&gt; parse_dl_name_version(&quot;sfml-audio-2.dll&quot;, &quot;windows&quot;)[1]
&quot;sfml-audio&quot;</code></pre><p>If the library would have different basenames on different operating systems (e.g., <code>libz.so</code> on Linux and FreeBSD, <code>libz.dylib</code> on macOS, and <code>zlib.dll</code> on Windows), <code>libname</code> can be also a vector of <code>String</code>s with the different alternatives:</p><pre><code class="language-none">LibraryProduct([&quot;libz&quot;, &quot;zlib&quot;], :libz)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Products.jl#L68-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.Product" href="#BinaryBuilderBase.Product"><code>BinaryBuilderBase.Product</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>Product</code> is an expected result after building or installation of a package.</p><p>Examples of <code>Product</code>s include <a href="#BinaryBuilderBase.LibraryProduct"><code>LibraryProduct</code></a>, <a href="#BinaryBuilderBase.FrameworkProduct"><code>FrameworkProduct</code></a>, <a href="#BinaryBuilderBase.ExecutableProduct"><code>ExecutableProduct</code></a> and <a href="#BinaryBuilderBase.FileProduct"><code>FileProduct</code></a>. All <code>Product</code> types must define the following minimum set of functionality:</p><ul><li><p><a href="#BinaryBuilderBase.locate-Tuple{ExecutableProduct, Prefix}"><code>locate(::Product)</code></a>: given a <code>Product</code>, locate it within the wrapped <code>Prefix</code> returning its location as a string</p></li><li><p><a href="#BinaryBuilderBase.satisfied-Tuple{Product, Prefix}"><code>satisfied(::Product)</code></a>: given a <code>Product</code>, determine whether it has been successfully satisfied (e.g. it is locateable and it passes all callbacks)</p></li><li><p><a href="#BinaryBuilderBase.variable_name-Tuple{Product}"><code>variable_name(::Product)</code></a>: return the variable name assigned to a <code>Product</code></p></li><li><p><code>repr(::Product)</code>: Return a representation of this <code>Product</code>, useful for auto-generating source code that constructs <code>Products</code>, if that&#39;s your thing.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Products.jl#L5-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.UserNSRunner" href="#BinaryBuilderBase.UserNSRunner"><code>BinaryBuilderBase.UserNSRunner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UserNSRunner</code></pre><p>A <code>UserNSRunner</code> represents an &quot;execution context&quot;, an object that bundles all necessary information to run commands within the container that contains our crossbuild environment.  Use <code>run()</code> to actually run commands within the <code>UserNSRunner</code>, and <a href="#BinaryBuilderBase.runshell"><code>runshell()</code></a> as a quick way to get an interactive shell within the crossbuild environment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/UserNSRunner.jl#L3-L11">source</a></section></article><h2 id="Functions-1"><a class="docs-heading-anchor" href="#Functions-1">Functions</a><a class="docs-heading-anchor-permalink" href="#Functions-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.bindir-Tuple{Prefix}" href="#BinaryBuilderBase.bindir-Tuple{Prefix}"><code>BinaryBuilderBase.bindir</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bindir(prefix::Prefix)</code></pre><p>Returns the binary directory for the given <code>prefix</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Prefix.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.choose_shards-Tuple{Base.BinaryPlatforms.AbstractPlatform}" href="#BinaryBuilderBase.choose_shards-Tuple{Base.BinaryPlatforms.AbstractPlatform}"><code>BinaryBuilderBase.choose_shards</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">choose_shards(p::AbstractPlatform; rootfs_build, ps_build, GCC_builds,
                           LLVM_builds, archive_type)</code></pre><p>This method chooses, given a <code>Platform</code>, which shards to download, extract and mount, returning a list of <code>CompilerShard</code> objects.  At the moment, this always consists of four shards, but that may not always be the case.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Rootfs.jl#L540-L547">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.compress_dir-Tuple{AbstractString}" href="#BinaryBuilderBase.compress_dir-Tuple{AbstractString}"><code>BinaryBuilderBase.compress_dir</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compress_dir(dir::AbstractString;
             compressor_stream = GzipCompressorStream,
             level::Int = 9,
             extension::AbstractString = &quot;.gz&quot;,
             verbose::Bool = false)</code></pre><p>Compress all files in <code>dir</code> using the specified <code>compressor_stream</code> with compression level equal to <code>level</code>, appending <code>extension</code> to the filenames. Remove the original uncompressed files at the end.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Prefix.jl#L712-L722">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.download_source" href="#BinaryBuilderBase.download_source"><code>BinaryBuilderBase.download_source</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">download_source(source::AbstractSource; verbose::Bool = false)</code></pre><p>Download the given <code>source</code>.  All downloads are cached within the BinaryBuilder <code>downloads</code> storage directory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Sources.jl#L190-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.expand_cxxstring_abis-Tuple{Base.BinaryPlatforms.AbstractPlatform}" href="#BinaryBuilderBase.expand_cxxstring_abis-Tuple{Base.BinaryPlatforms.AbstractPlatform}"><code>BinaryBuilderBase.expand_cxxstring_abis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">expand_cxxstring_abis(p::AbstractPlatform; skip=Sys.isbsd)</code></pre><p>Given a <code>Platform</code>, returns an array of <code>Platforms</code> with a spread of identical entries with the exception of the <code>cxxstring_abi</code> tag within the <code>Platform</code> object.  This is used to take, for example, a list of supported platforms and expand them to include multiple GCC versions for the purposes of ABI matching.</p><p>If the given <code>Platform</code> already specifies a <code>cxxstring_abi</code> (as opposed to <code>nothing</code>) only that <code>Platform</code> is returned.  If <code>skip</code> is a function for which <code>skip(platform)</code> evaluates to <code>true</code>, the given platform is not expanded.  By default FreeBSD and macOS platforms are skipped, due to their lack of a dependence on <code>libstdc++</code> and not needing this compatibility shim.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Rootfs.jl#L767-L780">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.expand_gfortran_versions-Tuple{Base.BinaryPlatforms.AbstractPlatform}" href="#BinaryBuilderBase.expand_gfortran_versions-Tuple{Base.BinaryPlatforms.AbstractPlatform}"><code>BinaryBuilderBase.expand_gfortran_versions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">expand_gfortran_versions(p::AbstractPlatform)</code></pre><p>Given a <code>Platform</code>, returns an array of <code>Platforms</code> with a spread of identical entries with the exception of the <code>libgfortran_version</code> tag within the <code>Platform</code>.  This is used to take, for example, a list of supported platforms and expand them to include multiple GCC versions for the purposes of ABI matching.  If the given <code>Platform</code> already specifies a <code>libgfortran_version</code> (as opposed to <code>nothing</code>) only that <code>Platform</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Rootfs.jl#L731-L740">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.expand_microarchitectures" href="#BinaryBuilderBase.expand_microarchitectures"><code>BinaryBuilderBase.expand_microarchitectures</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expand_microarchitectures(ps::Vector{&lt;:Platform}, [microarchitectures::Vector{String}];
                          filter=Returns(true))</code></pre><p>Expand all platforms in the vector <code>ps</code> with the supported microarchitectures.</p><p>If the <code>microarchitectures</code> argument is given, limit the expansion to the given platforms.  This is useful if you do not want to expand to all available microarchitectures.</p><p>The expansion is applied only to the platforms matching the <code>filter</code> predicate, by default all platforms.  This is useful if you want to limit the expansion to some platforms, without having to explicitly list its microarchitectures in the second argument.</p><pre><code class="language-julia-repl">julia&gt; using BinaryBuilderBase

julia&gt; expand_microarchitectures(filter!(p -&gt; Sys.islinux(p) &amp;&amp; libc(p) == &quot;glibc&quot;, supported_platforms()))
14-element Vector{Platform}:
 Linux i686 {libc=glibc, march=pentium4}
 Linux i686 {libc=glibc, march=prescott}
 Linux x86_64 {libc=glibc, march=x86_64}
 Linux x86_64 {libc=glibc, march=avx}
 Linux x86_64 {libc=glibc, march=avx2}
 Linux x86_64 {libc=glibc, march=avx512}
 Linux aarch64 {libc=glibc, march=armv8_0}
 Linux aarch64 {libc=glibc, march=armv8_1}
 Linux aarch64 {libc=glibc, march=armv8_2_crypto}
 Linux aarch64 {libc=glibc, march=a64fx}
 Linux armv6l {call_abi=eabihf, libc=glibc, march=arm1176jzfs}
 Linux armv7l {call_abi=eabihf, libc=glibc, march=armv7l}
 Linux armv7l {call_abi=eabihf, libc=glibc, march=neonvfpv4}
 Linux powerpc64le {libc=glibc, march=power8}

julia&gt; expand_microarchitectures(filter!(p -&gt; Sys.islinux(p) &amp;&amp; libc(p) == &quot;glibc&quot;, supported_platforms()), [&quot;x86_64&quot;, &quot;avx2&quot;])
7-element Vector{Platform}:
 Linux i686 {libc=glibc}
 Linux x86_64 {libc=glibc, march=x86_64}
 Linux x86_64 {libc=glibc, march=avx2}
 Linux aarch64 {libc=glibc}
 Linux armv6l {call_abi=eabihf, libc=glibc}
 Linux armv7l {call_abi=eabihf, libc=glibc}
 Linux powerpc64le {libc=glibc}

julia&gt; expand_microarchitectures(filter!(p -&gt; Sys.islinux(p) &amp;&amp; libc(p) == &quot;glibc&quot;, supported_platforms()); filter=p-&gt;arch(p)==&quot;x86_64&quot;)
9-element Vector{Platform}:
 Linux i686 {libc=glibc}
 Linux x86_64 {libc=glibc, march=x86_64}
 Linux x86_64 {libc=glibc, march=avx}
 Linux x86_64 {libc=glibc, march=avx2}
 Linux x86_64 {libc=glibc, march=avx512}
 Linux aarch64 {libc=glibc}
 Linux armv6l {call_abi=eabihf, libc=glibc}
 Linux armv7l {call_abi=eabihf, libc=glibc}
 Linux powerpc64le {libc=glibc}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Rootfs.jl#L867-L924">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.expand_microarchitectures" href="#BinaryBuilderBase.expand_microarchitectures"><code>BinaryBuilderBase.expand_microarchitectures</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expand_microarchitectures(p::AbstractPlatform, [microarchitectures::Vector{String}])</code></pre><p>Given a <code>Platform</code>, returns a vector of <code>Platforms</code> with differing <code>march</code> attributes as specified by the <code>ARCHITECTURE_FLAGS</code> mapping.  If the given <code>Platform</code> alread has a <code>march</code> tag specified, only that platform is returned.  If the <code>microarchitectures</code> argument is given, limit the expansion to the given microarchitectures.</p><pre><code class="language-julia-repl">julia&gt; using BinaryBuilderBase

julia&gt; expand_microarchitectures(Platform(&quot;x86_64&quot;, &quot;freebsd&quot;))
4-element Vector{Platform}:
 FreeBSD x86_64 {march=x86_64}
 FreeBSD x86_64 {march=avx}
 FreeBSD x86_64 {march=avx2}
 FreeBSD x86_64 {march=avx512}

julia&gt; expand_microarchitectures(Platform(&quot;armv7l&quot;, &quot;linux&quot;))
2-element Vector{Platform}:
 Linux armv7l {call_abi=eabihf, libc=glibc, march=armv7l}
 Linux armv7l {call_abi=eabihf, libc=glibc, march=neonvfpv4}

julia&gt; expand_microarchitectures(Platform(&quot;aarch64&quot;, &quot;linux&quot;), [&quot;armv8_0&quot;, &quot;a64fx&quot;])
2-element Vector{Platform}:
 Linux aarch64 {libc=glibc, march=armv8_0}
 Linux aarch64 {libc=glibc, march=a64fx}

julia&gt; expand_microarchitectures(Platform(&quot;i686&quot;, &quot;windows&quot;))
2-element Vector{Platform}:
 Windows i686 {march=pentium4}
 Windows i686 {march=prescott}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Rootfs.jl#L798-L831">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.filter_platforms-Tuple{AbstractVector{&lt;:AbstractDependency}, Base.BinaryPlatforms.AbstractPlatform}" href="#BinaryBuilderBase.filter_platforms-Tuple{AbstractVector{&lt;:AbstractDependency}, Base.BinaryPlatforms.AbstractPlatform}"><code>BinaryBuilderBase.filter_platforms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">filter_platforms(deps::AbstractVector{&lt;:AbstractDependency}, p::AbstractPlatform)</code></pre><p>Filter the dependencies <code>deps</code> which are compatible with platform <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Dependencies.jl#L175-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.gcc_version" href="#BinaryBuilderBase.gcc_version"><code>BinaryBuilderBase.gcc_version</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gcc_version(p::AbstractPlatform, GCC_builds::Vector{GCCBuild},
            compilers::Vector{Symbol}=[:c];
            llvm_version::Union{Nothing,VersionNumber}=nothing)</code></pre><p>Returns the closest matching GCC version number for the given particular platform, from the given set of options.  The compiler ABI and the microarchitecture of the platform will be taken into account.  If no match is found, returns an empty list.  <code>compilers</code> is the list of compilers used in the build, to choose the right version of GCC to couple with them if necessary.  If the keyword argument <code>llvm_version</code> is passed, it is used to filter the version of GCC for FreeBSD platforms.</p><p>This method assumes that the compiler ABI of the platform represents a platform that binaries will be run on, and thus versions are always rounded down; e.g. if the platform supports a <code>libstdc++</code> version that corresponds to <code>GCC 5.1.0</code>, but the only GCC versions available to be picked from are <code>4.8.5</code> and <code>5.2.0</code>, it will return <code>4.8.5</code>, as binaries compiled with that version will run on this platform, whereas binaries compiled with <code>5.2.0</code> may not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Rootfs.jl#L416-L435">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.generate_compiler_wrappers!-Tuple{Base.BinaryPlatforms.AbstractPlatform}" href="#BinaryBuilderBase.generate_compiler_wrappers!-Tuple{Base.BinaryPlatforms.AbstractPlatform}"><code>BinaryBuilderBase.generate_compiler_wrappers!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">generate_compiler_wrappers!(platform::AbstractPlatform; bin_path::AbstractString,
                            host_platform::AbstractPlatform = Platform(&quot;x86_64&quot;, &quot;linux&quot;; libc = &quot;musl&quot;, cxxstring_abi = &quot;cxx11&quot;),
                            compilers::Vector{Symbol} = [:c],
                            allow_unsafe_flags::Bool = false,
                            lock_microarchitecture::Bool = true)</code></pre><p>We generate a set of compiler wrapper scripts within our build environment to force all build systems to honor the necessary sets of compiler flags to build for our systems. Note that while <code>platform_envs()</code> sets many environment variables, those values are intended to be optional/overridable.  These values, while still overridable by directly invoking a compiler binary directly (e.g. /opt/{target}/bin/{target}-gcc), are much more difficult to override, as the flags embedded in these wrappers are absolutely necessary, and even simple programs will not compile without them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Runner.jl#L140-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.get_concrete_platform-Tuple{Base.BinaryPlatforms.AbstractPlatform}" href="#BinaryBuilderBase.get_concrete_platform-Tuple{Base.BinaryPlatforms.AbstractPlatform}"><code>BinaryBuilderBase.get_concrete_platform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_concrete_platform(platform::AbstractPlatform;
                      preferred_gcc_version = nothing,
                      preferred_llvm_version = nothing,
                      compilers = nothing)</code></pre><p>Return the concrete platform for the given <code>platform</code> based on the GCC compiler ABI.  The set of shards is chosen by the keyword arguments (see <a href="#BinaryBuilderBase.choose_shards-Tuple{Base.BinaryPlatforms.AbstractPlatform}"><code>choose_shards</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/utils.jl#L46-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.get_concrete_platform-Tuple{Platform, Vector{CompilerShard}}" href="#BinaryBuilderBase.get_concrete_platform-Tuple{Platform, Vector{CompilerShard}}"><code>BinaryBuilderBase.get_concrete_platform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_concrete_platform(platform::Platform, shards::Vector{CompilerShard})</code></pre><p>Return the concrete platform for the given <code>platform</code> based on the GCC compiler ABI in the <code>shards</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/utils.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.includedir-Tuple{Prefix}" href="#BinaryBuilderBase.includedir-Tuple{Prefix}"><code>BinaryBuilderBase.includedir</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">includedir(prefix::Prefix)</code></pre><p>Returns the include directory for the given <code>prefix</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Prefix.jl#L99-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.is_build_dependency" href="#BinaryBuilderBase.is_build_dependency"><code>BinaryBuilderBase.is_build_dependency</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_build_dependency(dep::AbstractDependency) -&gt; Bool</code></pre><p>Return whether <code>dep</code> is a build-time dependency or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Dependencies.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.is_host_dependency" href="#BinaryBuilderBase.is_host_dependency"><code>BinaryBuilderBase.is_host_dependency</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_host_dependency(dep::AbstractDependency) -&gt; Bool</code></pre><p>Return whether <code>dep</code> is a dependency of the host platform or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Dependencies.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.is_runtime_dependency" href="#BinaryBuilderBase.is_runtime_dependency"><code>BinaryBuilderBase.is_runtime_dependency</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_runtime_dependency(dep::AbstractDependency) -&gt; Bool</code></pre><p>Return whether <code>dep</code> is a runtime dependency or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Dependencies.jl#L50-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.is_target_dependency-Tuple{AbstractDependency}" href="#BinaryBuilderBase.is_target_dependency-Tuple{AbstractDependency}"><code>BinaryBuilderBase.is_target_dependency</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_target_dependency(dep::AbstractDependency) -&gt; Bool</code></pre><p>Return whether <code>dep</code> is a dependency of the target platform or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Dependencies.jl#L36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.libdirs" href="#BinaryBuilderBase.libdirs"><code>BinaryBuilderBase.libdirs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">libdirs(prefix::Prefix, platform = HostPlatform())</code></pre><p>Returns the library directories for the given <code>prefix</code> (note that this differs between unix systems and windows systems, and between 32- and 64-bit systems).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Prefix.jl#L81-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.locate-Tuple{ExecutableProduct, Prefix}" href="#BinaryBuilderBase.locate-Tuple{ExecutableProduct, Prefix}"><code>BinaryBuilderBase.locate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">locate(ep::ExecutableProduct, prefix::Prefix;
       platform::AbstractPlatform = HostPlatform(),
       verbose::Bool = false,
       isolate::Bool = false)</code></pre><p>If the given executable file exists and is executable, return its path.</p><p>On all platforms, an <a href="#BinaryBuilderBase.ExecutableProduct"><code>ExecutableProduct</code></a> checks for existence of the file.  On non-Windows platforms, it will check for the executable bit being set. On Windows platforms, it will check that the file ends with &quot;.exe&quot;, (adding it on automatically, if it is not already present).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Products.jl#L388-L400">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.locate-Tuple{FileProduct, Prefix}" href="#BinaryBuilderBase.locate-Tuple{FileProduct, Prefix}"><code>BinaryBuilderBase.locate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">locate(fp::FileProduct, prefix::Prefix;
       platform::AbstractPlatform = HostPlatform(),
       verbose::Bool = false,
       isolate::Bool = false)</code></pre><p>If the given file exists, return its path.  The <code>platform</code> and <code>isolate</code> arguments are is ignored here, but included for uniformity.  For ease of use, we support a limited number of custom variable expansions such as <code>${target}</code>, and <code>${nbits}</code>, so that the detection of files within target-specific folders named things like <code>/lib32/i686-linux-musl</code> is simpler.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Products.jl#L466-L477">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.locate-Tuple{LibraryProduct, Prefix}" href="#BinaryBuilderBase.locate-Tuple{LibraryProduct, Prefix}"><code>BinaryBuilderBase.locate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">locate(lp::LibraryProduct, prefix::Prefix;
       verbose::Bool = false,
       platform::AbstractPlatform = HostPlatform())</code></pre><p>If the given library exists (under any reasonable name) and is <code>dlopen()</code>able, (assuming it was built for the current platform) return its location.  Note that the <code>dlopen()</code> test is only run if the current platform matches the given <code>platform</code> keyword argument, as cross-compiled libraries cannot be <code>dlopen()</code>ed on foreign platforms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Products.jl#L179-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.logdir-Tuple{Prefix}" href="#BinaryBuilderBase.logdir-Tuple{Prefix}"><code>BinaryBuilderBase.logdir</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">logdir(prefix::Prefix; subdir::AbstractString=&quot;&quot;)</code></pre><p>Returns the logs directory for the given <code>prefix</code>.  If <code>subdir</code> is a non-empty string, that directory it is appended to the logdir of the given <code>prefix</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Prefix.jl#L108-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.package-Tuple{Prefix, AbstractString, VersionNumber}" href="#BinaryBuilderBase.package-Tuple{Prefix, AbstractString, VersionNumber}"><code>BinaryBuilderBase.package</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">package(prefix::Prefix, output_base::AbstractString,
        version::VersionNumber;
        platform::AbstractPlatform = HostPlatform(),
        verbose::Bool = false, force::Bool = false)</code></pre><p>Build a tarball of the <code>prefix</code>, storing the tarball at <code>output_base</code>, appending a version number, a platform-dependent suffix and a file extension. If no platform is given, defaults to current platform. Returns the full path to, the SHA256 hash and the git tree SHA1 of the generated tarball.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Prefix.jl#L118-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.preferred_cxxstring_abi-Tuple{Base.BinaryPlatforms.AbstractPlatform, CompilerShard}" href="#BinaryBuilderBase.preferred_cxxstring_abi-Tuple{Base.BinaryPlatforms.AbstractPlatform, CompilerShard}"><code>BinaryBuilderBase.preferred_cxxstring_abi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">preferred_cxxstring_abi(platform::AbstractPlatform, shard::CompilerShard;
                        gcc_builds::Vector{GCCBuild} = available_gcc_builds)</code></pre><p>Return the C++ string ABI preferred by the given platform or GCCBootstrap shard.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Rootfs.jl#L971-L976">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.preferred_libgfortran_version-Tuple{Base.BinaryPlatforms.AbstractPlatform, CompilerShard}" href="#BinaryBuilderBase.preferred_libgfortran_version-Tuple{Base.BinaryPlatforms.AbstractPlatform, CompilerShard}"><code>BinaryBuilderBase.preferred_libgfortran_version</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">preferred_libgfortran_version(platform::AbstractPlatform, shard::CompilerShard;
                              gcc_builds::Vector{GCCBuild} = available_gcc_builds)</code></pre><p>Return the libgfortran version preferred by the given platform or GCCBootstrap shard.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Rootfs.jl#L941-L946">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.satisfied-Tuple{Product, Prefix}" href="#BinaryBuilderBase.satisfied-Tuple{Product, Prefix}"><code>BinaryBuilderBase.satisfied</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">satisfied(p::Product;
          platform::AbstractPlatform = HostPlatform(),
          verbose::Bool = false,
          isolate::Bool = false)</code></pre><p>Given a <a href="#BinaryBuilderBase.Product"><code>Product</code></a>, return <code>true</code> if that <code>Product</code> is satisfied, e.g. whether a file exists that matches all criteria setup for that <code>Product</code>. If <code>isolate</code> is set to <code>true</code>, will isolate all checks from the main Julia process in the event that <code>dlopen()</code>&#39;ing a library might cause issues.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Products.jl#L42-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.setup_dependencies-Tuple{Prefix, Vector{Pkg.Types.PackageSpec}, Base.BinaryPlatforms.AbstractPlatform}" href="#BinaryBuilderBase.setup_dependencies-Tuple{Prefix, Vector{Pkg.Types.PackageSpec}, Base.BinaryPlatforms.AbstractPlatform}"><code>BinaryBuilderBase.setup_dependencies</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setup_dependencies(prefix::Prefix, dependencies::Vector{PackageSpec}, platform::AbstractPlatform; verbose::Bool = false)</code></pre><p>Given a list of JLL package specifiers, install their artifacts into the build prefix. The artifacts are installed into the global artifact store, then copied into a temporary location, then finally symlinked into the build prefix.  This allows us to (a) save download bandwidth by not downloading the same artifacts over and over again, (b) maintain separation in the event of catastrophic containment failure, avoiding hosing the main system if a build script decides to try to modify the dependent artifact files, and (c) keeping a record of what files are a part of dependencies as opposed to the package being built, in the form of symlinks to a specific artifacts directory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Prefix.jl#L553-L564">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.setup_workspace" href="#BinaryBuilderBase.setup_workspace"><code>BinaryBuilderBase.setup_workspace</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setup_workspace(build_path::String, sources::Vector{SetupSource};
                verbose::Bool = false)</code></pre><p>Sets up a workspace within <code>build_path</code>, creating the directory structure needed by further steps, unpacking the source within <code>build_path</code>, and defining the environment variables that will be defined within the sandbox environment.</p><p>This method returns the <code>Prefix</code> to install things into, and the runner that can be used to launch commands within this workspace.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Prefix.jl#L332-L342">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.supported_platforms-Tuple{}" href="#BinaryBuilderBase.supported_platforms-Tuple{}"><code>BinaryBuilderBase.supported_platforms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">supported_platforms(;exclude::Union{Vector{&lt;:Platform},Function}=Returns(false),
                    experimental::Bool=false)</code></pre><p>Return the list of supported platforms as an array of <code>Platform</code>s.  These are the platforms we officially support building for, if you see a mapping in <code>get_shard_hash()</code> that isn&#39;t represented here, it&#39;s probably because that platform is still considered &quot;in beta&quot;.  If <code>experimental=true</code>, include platforms considered experimental.</p><p>Platforms can be excluded from the list by specifying an array of platforms to <code>exclude</code> i.e. <code>supported_platforms(exclude=[Platform(&quot;i686&quot;, &quot;windows&quot;), Platform(&quot;x86_64&quot;, &quot;windows&quot;)])</code> or a function that returns true for exclusions i.e.</p><pre><code class="language-none">supported_platforms(exclude=Sys.islinux)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Rootfs.jl#L677-L692">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.temp_prefix-Tuple{Function}" href="#BinaryBuilderBase.temp_prefix-Tuple{Function}"><code>BinaryBuilderBase.temp_prefix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">temp_prefix(func::Function)</code></pre><p>Create a temporary prefix, passing the prefix into the user-defined function so that build/packaging operations can occur within the temporary prefix, which is then cleaned up after all operations are finished.  If the path provided exists already, it will be deleted.</p><p>Usage example:</p><pre><code class="language-none">out_path = abspath(&quot;./libfoo&quot;)
temp_prefix() do p
    # &lt;insert build steps here&gt;

    # tarball up the built package
    tarball_path, tarball_hash = package(p, out_path)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Prefix.jl#L9-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.variable_name-Tuple{Product}" href="#BinaryBuilderBase.variable_name-Tuple{Product}"><code>BinaryBuilderBase.variable_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">variable_name(p::Product)</code></pre><p>Return the variable name associated with this <a href="#BinaryBuilderBase.Product"><code>Product</code></a> as a string</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Products.jl#L58-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.abi_agnostic-Tuple{Platform}" href="#BinaryBuilderBase.abi_agnostic-Tuple{Platform}"><code>BinaryBuilderBase.abi_agnostic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">abi_agnostic(p::AbstractPlatform)</code></pre><p>Strip out any tags that are not the basic annotations like <code>libc</code> and <code>call_abi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Platforms.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.accept_apple_sdk-Tuple{IO, IO}" href="#BinaryBuilderBase.accept_apple_sdk-Tuple{IO, IO}"><code>BinaryBuilderBase.accept_apple_sdk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">accept_apple_sdk(ins::IO, outs::IO) -&gt; Bool</code></pre><p>Ask the user whether they accept the terms of the macOS SDK, and return a boolean with their choice.  Write messages to <code>outs</code>, read input from <code>ins</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Rootfs.jl#L191-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.artifact_name-Tuple{CompilerShard}" href="#BinaryBuilderBase.artifact_name-Tuple{CompilerShard}"><code>BinaryBuilderBase.artifact_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">artifact_name(cs::CompilerShard)</code></pre><p>Return the bound artifact name for a particular shard.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Rootfs.jl#L60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.chown_cleanup-Tuple{DockerRunner}" href="#BinaryBuilderBase.chown_cleanup-Tuple{DockerRunner}"><code>BinaryBuilderBase.chown_cleanup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">chown_cleanup(dr::DockerRunner)</code></pre><p>On Linux, the user id inside of the docker container doesn&#39;t correspond to ours on the outside, so permissions get all kinds of screwed up.  To fix this, we have to <code>chown -R $(id -u):$(id -g) $prefix</code>, which really sucks, but is still better than nothing.  This is why we prefer the UserNSRunner on Linux.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/DockerRunner.jl#L120-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.collect_jll_uuids-Tuple{Pkg.Types.Manifest, Set{Base.UUID}}" href="#BinaryBuilderBase.collect_jll_uuids-Tuple{Pkg.Types.Manifest, Set{Base.UUID}}"><code>BinaryBuilderBase.collect_jll_uuids</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">collect_jll_uuids(manifest::Pkg.Types.Manifest, dependencies::Set{Base.UUID})</code></pre><p>Return a <code>Set</code> of all JLL packages in the <code>manifest</code> with <code>dependencies</code> being the list of direct dependencies of the environment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Prefix.jl#L380-L385">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.download_all_artifacts-Tuple{}" href="#BinaryBuilderBase.download_all_artifacts-Tuple{}"><code>BinaryBuilderBase.download_all_artifacts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">download_all_artifacts(; verbose::Bool=false)</code></pre><p>Helper function to download all shards/helper binaries so that no matter what happens, you don&#39;t need an internet connection to build your precious, precious binaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Rootfs.jl#L1001-L1007">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.enable_apple_file-Tuple{}" href="#BinaryBuilderBase.enable_apple_file-Tuple{}"><code>BinaryBuilderBase.enable_apple_file</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">enable_apple_file()</code></pre><p>Return the path to file that, if exists, indicates that the user accepts to download macOS SDK.  The file is automatically created when the package is loaded if the environment variable <code>BINARYBUILDER_AUTOMATIC_APPLE</code> is set to <code>&quot;true&quot;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/BinaryBuilderBase.jl#L54-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.generate_per_uid_squashfs" href="#BinaryBuilderBase.generate_per_uid_squashfs"><code>BinaryBuilderBase.generate_per_uid_squashfs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">generate_per_uid_squashfs(cs, new_uid = getuid())</code></pre><p>In order for the sandbox to work well, we need to have the uids of the squashfs images match the uid of the current unprivileged user.  Unfortunately there is no mount-time option to do this for us.  Fortunately, squashfs is simple enough that if the ID table is uncompressed, we can just manually patch the uids to be what we need.  This function performs this operation, by rewriting all UIDs and GIDs to the given <code>new_uid</code> (which defaults to the current user&#39;s UID).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/squashfs_utils.jl#L31-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.get_addable_spec-Tuple{AbstractString, VersionNumber}" href="#BinaryBuilderBase.get_addable_spec-Tuple{AbstractString, VersionNumber}"><code>BinaryBuilderBase.get_addable_spec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_addable_spec(name::AbstractString, version::VersionNumber)</code></pre><p>Given a JLL name and registered version, return a <code>PackageSpec</code> that, when passed as a <code>Dependency</code>, ensures that exactly that version will be installed.  Example usage:</p><pre><code class="language-none">dependencies = [
    BuildDependency(get_addable_spec(&quot;LLVM_jll&quot;, v&quot;9.0.1+0&quot;)),
]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Prefix.jl#L454-L463">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.get_commit_sha-Tuple{String, Base.SHA1}" href="#BinaryBuilderBase.get_commit_sha-Tuple{String, Base.SHA1}"><code>BinaryBuilderBase.get_commit_sha</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_commit_sha(url::String, tree_hash::Base.SHA1; verbose::Bool=false)</code></pre><p>Find the latest git commit corresponding to the given git tree SHA1 for the remote repository with the given <code>url</code>.  The repository is cached locally for quicker future access.  If <code>verbose</code> is <code>true</code>, print to screen some debugging information.</p><p>The return value is the commit SHA as a <code>String</code>, if the corresponding revision is found, <code>nothing</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Prefix.jl#L416-L425">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.get_tree_hash-Tuple{LibGit2.GitTree}" href="#BinaryBuilderBase.get_tree_hash-Tuple{LibGit2.GitTree}"><code>BinaryBuilderBase.get_tree_hash</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_tree_hash(tree::LibGit2.GitTree)</code></pre><p>Given a <code>GitTree</code>, get the <code>GitHash</code> that identifies it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Prefix.jl#L404-L408">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.getgid-Tuple{}" href="#BinaryBuilderBase.getgid-Tuple{}"><code>BinaryBuilderBase.getgid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getgid()</code></pre><p>Wrapper around libc&#39;s <code>getgid()</code> function</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/squashfs_utils.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.getuid-Tuple{}" href="#BinaryBuilderBase.getuid-Tuple{}"><code>BinaryBuilderBase.getuid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getuid()</code></pre><p>Wrapper around libc&#39;s <code>getuid()</code> function</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/squashfs_utils.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.import_docker_image-Tuple{CompilerShard, String}" href="#BinaryBuilderBase.import_docker_image-Tuple{CompilerShard, String}"><code>BinaryBuilderBase.import_docker_image</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">import_docker_image(rootfs::CompilerShard; verbose::Bool = false)</code></pre><p>Checks to see if the given rootfs has been imported into docker yet; if it hasn&#39;t, then do so so that we can run things like:</p><pre><code class="language-none">docker run -ti binarybuilder_rootfs:v2018.08.27 /bin/bash</code></pre><p>Which, after all, is the foundation upon which this whole doodad is built.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/DockerRunner.jl#L30-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.installed_shards-Tuple{}" href="#BinaryBuilderBase.installed_shards-Tuple{}"><code>BinaryBuilderBase.installed_shards</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">installed_shards()</code></pre><p>Return a vector of compiler shards currently downloaded on the local system</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Rootfs.jl#L1075-L1078">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.is_ecryptfs-Tuple{AbstractString}" href="#BinaryBuilderBase.is_ecryptfs-Tuple{AbstractString}"><code>BinaryBuilderBase.is_ecryptfs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_ecryptfs(path::AbstractString; verbose::Bool=false)</code></pre><p>Checks to see if the given <code>path</code> (or any parent directory) is placed upon an <code>ecryptfs</code> mount.  This is known not to work on current kernels, see this bug for more details: https://bugzilla.kernel.org/show_bug.cgi?id=197603</p><p>This method returns whether it is encrypted or not, and what mountpoint it used to make that decision.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/UserNSRunner.jl#L382-L391">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.is_mounted-Tuple{CompilerShard, AbstractString}" href="#BinaryBuilderBase.is_mounted-Tuple{CompilerShard, AbstractString}"><code>BinaryBuilderBase.is_mounted</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_mounted(cs::CompilerShard, build_prefix::String)</code></pre><p>Return true if the given shard is mounted.  Uses <code>run()</code> so will error out if something goes awry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Rootfs.jl#L292-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.macos_sdk_already_installed-Tuple{}" href="#BinaryBuilderBase.macos_sdk_already_installed-Tuple{}"><code>BinaryBuilderBase.macos_sdk_already_installed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">macos_sdk_already_installed()</code></pre><p>Returns <code>true</code> if any piece of the MacOS SDK is already installed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Rootfs.jl#L338-L342">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.map_target-Tuple{CompilerShard}" href="#BinaryBuilderBase.map_target-Tuple{CompilerShard}"><code>BinaryBuilderBase.map_target</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">map_target(cs::CompilerShard)</code></pre><p>Return the location this compiler shard should be mounted at.  We basically analyze the name and platform of this shard and return a path based on that.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Rootfs.jl#L160-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.mount-Tuple{CompilerShard, AbstractString}" href="#BinaryBuilderBase.mount-Tuple{CompilerShard, AbstractString}"><code>BinaryBuilderBase.mount</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mount(cs::CompilerShard, build_prefix::String)</code></pre><p>Mount a compiler shard, if possible.  Uses <code>run()</code> so will error out if something goes awry.  Note that this function only does something when using a <code>.squashfs</code> shard, with a UserNS or Docker runner, on Linux. All other combinations of shard archive type, runner and platform result in a no-op from this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Rootfs.jl#L220-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.platform_envs-Tuple{Base.BinaryPlatforms.AbstractPlatform, AbstractString}" href="#BinaryBuilderBase.platform_envs-Tuple{Base.BinaryPlatforms.AbstractPlatform, AbstractString}"><code>BinaryBuilderBase.platform_envs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">platform_envs(platform::AbstractPlatform, src_name::AbstractString;
              host_platform = default_host_platform,
              bootstrap::Bool=!isempty(bootstrap_list),
              compilers::Vector{Symbol}=[:c],
              rust_version::Union{Nothing,VersionNumber}=nothing,
              verbose::Bool = false,
              )</code></pre><p>Given a <code>platform</code> and a <code>src_name</code>, generate a <code>Dict</code> mapping representing all the environment variables to be set within the build environment to force compiles toward the defined target architecture.  Examples of things set are <code>PATH</code>, <code>CC</code>, <code>RANLIB</code>, as well as nonstandard things like <code>target</code>.</p><p>Accepted keyword arguments are:</p><ul><li><code>host_platform</code>: the platform of the host system,</li><li><code>bootstraop</code>: if <code>true</code>, only basic environment variables will be generated,</li><li><code>compilers</code>: list of compilers, some environment variables will be generated only if the relevant compilers are used (e.g., for Go and Rust),</li><li><code>rust_version</code>: version of the Rust toolchain, needed to set the environment variable <code>RUSTUP_TOOLCHAIN</code>,</li><li><code>verbose</code>: holds the value of the <code>V</code> and <code>VERBOSE</code> environment variables.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Runner.jl#L903-L926">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.platform_exeext-Tuple{Base.BinaryPlatforms.AbstractPlatform}" href="#BinaryBuilderBase.platform_exeext-Tuple{Base.BinaryPlatforms.AbstractPlatform}"><code>BinaryBuilderBase.platform_exeext</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">platform_exeext(p::AbstractPlatform)</code></pre><p>Get the executable extension for the given Platform.  Includes the leading <code>.</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Platforms.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.runshell" href="#BinaryBuilderBase.runshell"><code>BinaryBuilderBase.runshell</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">runshell(platform::AbstractPlatform = HostPlatform())</code></pre><p>Launch an interactive shell session within the user namespace, with environment setup to target the given <code>platform</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Runner.jl#L1183-L1188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.shard_mappings-Tuple{Vector{CompilerShard}}" href="#BinaryBuilderBase.shard_mappings-Tuple{Vector{CompilerShard}}"><code>BinaryBuilderBase.shard_mappings</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">shard_mappings(shards::Vector{CompilerShard})</code></pre><p>Return the default mappings for a set of compiler shards</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Rootfs.jl#L1040-L1044">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.shard_path-Tuple{CompilerShard}" href="#BinaryBuilderBase.shard_path-Tuple{CompilerShard}"><code>BinaryBuilderBase.shard_path</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">shard_path(cs::CompilerShard)</code></pre><p>Return the path to this shard on-disk; for unpacked shards, this is a directory. For squashfs shards, this is a file.  This will not cause a shard to be downloaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Rootfs.jl#L140-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.uname-Tuple{}" href="#BinaryBuilderBase.uname-Tuple{}"><code>BinaryBuilderBase.uname</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">uname()</code></pre><p>On Linux systems, return the strings returned by the <code>uname()</code> function in libc</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/UserNSRunner.jl#L212-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.unmount-Tuple{CompilerShard, String}" href="#BinaryBuilderBase.unmount-Tuple{CompilerShard, String}"><code>BinaryBuilderBase.unmount</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unmount(cs::CompilerShard, build_prefix::String)</code></pre><p>Unmount a compiler shard from a given build prefix, if possible.  Uses <code>run()</code> so will error out if something goes awry.  Note that this function only does something when using a squashfs shard on Linux.  All other combinations of shard archive type and platform result in a no-op.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/Rootfs.jl#L302-L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.versioninfo-Tuple{}" href="#BinaryBuilderBase.versioninfo-Tuple{}"><code>BinaryBuilderBase.versioninfo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">versioninfo()</code></pre><p>Helper function to print out some debugging information</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilderBase.jl/blob/88fd904d5dde5f340ab9e0cefb86a7894a0bb52d/src/BinaryBuilderBase.jl#L95-L99">source</a></section></article></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 5 April 2022 13:32">Tuesday 5 April 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
